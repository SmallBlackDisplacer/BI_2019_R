---
title: "Проект 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(dplyr)
library(ggplot2)
theme_set(theme_dark())
```

Привет! Вот функция:
```{r, echo=TRUE}
assemble_df <- function(dir_with_df) {
  files <- list.files(dir_with_df, pattern='*.csv')
  result <- c()
  for (file in files){
    if (is.null(result)){
      result <- read.csv(paste('Data/', file, sep = ''))
    } else {
      s <- read.csv(paste('Data/', file, sep = ''))
      result <- rbind(result, s)
    }
  }
  return(result)
}
```

```{r}
mollusks <- assemble_df('Data')
names(mollusks)[2] <- 'Sex'
mollusks$Sex <- as.factor(mollusks$Sex)
mollusks$Rings <- as.numeric(mollusks$Rings)
mollusks$Length <- as.numeric(mollusks$Length)
```

Насчет данных, в переменную Sex не все студенты записывали половую принадлежность одинаковым образом, поэтому получились такие уровни фактора: `r levels(mollusks$Sex)`

```{r}
levels(mollusks$Sex) <- c('male','female','juvenile','male','male','juvenile')
```

Я объединила одинаковые, теперь у моллюсков только три пола: `r levels(mollusks$Sex)`

Еще в данных есть пропущенные значения, вот их количество в каждом столбце: 
```{r}
sapply(mollusks, function(y) sum(length(which(is.na(y)))))
```

От них нужно избавиться, есть несколько вариантов, как это сделать.

1. Поскольку здесь много данных и мало пропущенных значений, можно просто убрать все строки с пропущенными значениями. Но тогда придется потерять часть информации, ведь вместе с пропущенными значениями будут выброшены и не пропущенные.

2. Заменить пропущенные значения на меры центральной тенденции. Поскольку пол - факторная переменная и там только одно пропущенное значение, в этом случае данную строку лучше убрать. Количество колец - счетная переменная, поэтому для замены пропущенных значений лучше использовать моду. Для всех остальных переменных можно использовать среднее значение.

3. Сначала, как и в первом случае, выбросить все строки с пропущенными значениями. Построить линейные модели по оставшимся значениям для каждой переменной с пропущенными значениями так, значения в каждой переменной можно было бы предсказать через значения остальных. С помощью полученных моделей предсказать пропущенные значения, заменить NA. После этого анализировать уже полные данные.

Мне кажется, третий вариант будет работать лучше всего, но в пока, для решения текущей задачи, я воспользуюсь вторым. Потом, если останется время, поробую третий. Можно будет сравнить результат.

```{r}
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

na_rm  <- function(x){
  zzz <- apply(x, 2, function(z) {
    z[is.na(z)] = mean(z, na.rm = TRUE)
    return (z)
  })
  return (as.data.frame(zzz))
}

mollusks <- mollusks[!is.na(mollusks$Sex),]
mollusks$Rings[is.na(mollusks$Rings)] <- getmode(mollusks$Rings)
mollusks <- cbind(mollusks[,c(1,2)],na_rm(mollusks[,c(3:9)]))

sapply(mollusks, function(y) sum(length(which(is.na(y)))))
```

Вот, все пропущенные значения заменены, кроме одной строчки, которую пришлось удалить.

Ниже приведены средние значения и стандартные отклонения переменной Length для моллюсков разного пола:
```{r}
mollusks %>% group_by(Sex) %>% summarise(mean = mean(Length), sd = sd(Length))
```
Среднее значение переменной Height не превышает 0.165 у `r round((dim(mollusks %>% filter(Height <= 0.165))[1]/dim(mollusks)[1])*100)`% моллюсков. Значение переменной Length = `r sort(mollusks$Length)[round(length(mollusks$Length)*0.92)]` выше чем у 92% от всех наблюдений.
Вот структура данных после добавления новой переменной Lenght_z_scores:

```{r}
mollusks <- mollusks %>% mutate(Lenght_z_scores = (Length - mean(Length))/sd(Length))
str(mollusks)
```

```{r}
rings_5_and_15 <- mollusks %>% filter(Rings == 5 | Rings == 15)
ggplot(rings_5_and_15, aes(Diameter))+
  geom_density(fill='white')+
  theme_dark()
```

Это частотное распределение диаметров моллюсков с количеством колец 5 и 15. На этом графике видно бимодальное распределение, которое выглядит так, как будто состоит из двух распределений, близких к нормальным, выборок из двух разных генеральных совокупностей. Сравним же t-критерием их.
```{r}
t.test(Diameter~Rings, data = rings_5_and_15)
```
Как мы видим, p-value меньше 0.05, что позволяет нам отвергнуть нулевую гипотезу о том, что диаметр моллюсков с количеством колец 5 и 15 не отличается.

Теперь посмотрим на переменные Diameter и Whole_weight.
```{r}
ggplot(mollusks, aes(Diameter,Whole_weight))+
  geom_point(col='white')
```

Зависимость между ними не линейная, поэтому линейная модель не могла бы удачно описать взаимосвязь этих переменных.
При этом зависимость кубического корня из Whole_weight от переменной Diameter уже больше похожа на линейную. 
```{r}
ggplot(mollusks, aes(Diameter,Whole_weight^(1/3)))+
  geom_point(col='white')
```

Заметно, что здесь нарушается условие гомоскедастичности. Похоже, я никак не могу это исправить, поэтому придется смириться с тем, что на больших значениях линейная модель будет предсказывать значения зависимой переменной хуже, но все еще достаточно неплохо.

Таким образом, можно построить линейную модель для этих двух переменных, по которой можно будет предсказывать их значения на рассматриваемом участке.
На этом графике заметно, что есть выброс в центре. Поскольку он в центре, он не повлияет на наклон линии тренда. Возможно, это пропущенное значение, которое было заменено на среднее.


```{r}
summary(lm(Whole_weight~Diameter, mollusks))
```

Вот линейная модель. Диаметр значимо влияет на вес моллюска и объясняет примерно 85% изменчивости этой переменной.


Теперь, можно посмотреть на данные. Прежде всего, интересно было бы попробвать заменить хотя бы часть пропущенных значений на предсказанные линейной моделью, а не на средние.
Насколько это будет полезно? На самом деле, замена количественных переменных на средние выгдядит хорошо, потому что, как бы сильно это значение ни отличалось от реального, оно минимально повлияет на линию регрессии, построенную с его учетом, так как будет находиться в центре.
Действительно интересно было бы попробовать предсказать пол, потому что как-то заменить его другим способом мы не можем. Вероятно, для этого понадобится нейронная сеть, потому что линейные модели могут предсказывать тоьлько количественные переменные.
Похоже, у меня не получится сейчас сделать нецронную сеть. Возможно, это можно было бы сделать как-то так

```{r echo=TRUE}
# install.packages("neuralnet")
# library(neuralnet)

# nn <- neuralnet(Sex~Length+Rings+Diameter+Shucked_weight+Height+Viscera_weight+Whole_weight+Shell_weight, data=mollusks)
```

Запускать этот код не нужно, он будет считаться вечно и это все равно плохое решение. Скорее всего, оно не будет работать совсем.